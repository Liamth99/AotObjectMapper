using System;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace AotObjectMapper.Mapper;

#pragma warning disable RS1038
[Generator]
public class MapperGenerator : IIncrementalGenerator
{
    /// <inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var mapperClasses = context
                           .SyntaxProvider
                           .CreateSyntaxProvider(
                                predicate: (node, _) => node is ClassDeclarationSyntax cds && cds.AttributeLists.Count > 0,
                                transform: (ctx,  _) => GetMapperCandidate(ctx)
                            )
                           .Where(x => x is not null);

        var compilationAndMappers = context.CompilationProvider.Combine(mapperClasses.Collect());

        context.RegisterSourceOutput(compilationAndMappers, (spc, source) => Execute(source.Left ,source.Right, spc));
    }

    private static INamedTypeSymbol? GetMapperCandidate(GeneratorSyntaxContext context)
    {
        var classSyntax = (ClassDeclarationSyntax)context.Node;
        var symbol      = context.SemanticModel.GetDeclaredSymbol(classSyntax);

        if (symbol is null)
            return null;

        if (symbol.GetAttributes().Any(attr => attr.AttributeClass?.Name == nameof(GenerateMapperAttribute)))
        {
            return symbol as INamedTypeSymbol;
        }

        return null;
    }

    private static void Execute(Compilation compilation, ImmutableArray<INamedTypeSymbol?> mappers, SourceProductionContext context)
    {
        foreach (var mapper in mappers.Distinct(SymbolEqualityComparer.Default))
        {
            if (mapper is null)
                continue;

            try
            {
                var attributes = mapper.GetAttributes();

                var mapAttributes = attributes.Where(a => a.AttributeClass?.Name == nameof(MapAttribute<,>));

                foreach (var mapAttr in mapAttributes)
                {
                    try
                    {
                        var sourceType      = mapAttr.AttributeClass!.TypeArguments[0];
                        var destinationType = mapAttr.AttributeClass!.TypeArguments[1];

                        var info = new MethodGenerationInfo((INamedTypeSymbol)mapper, sourceType, destinationType);

                        if (info.DestinationType.TypeKind is not TypeKind.Interface || !info.DestinationType.IsAbstract)
                        {
                            var populateCode = GeneratePopulationMethod(compilation, info);
                            context.AddSource($"Populate_{mapper.Name}_{sourceType.Name}_To_{destinationType.Name}.g.cs", SourceText.From(populateCode, Encoding.UTF8));
                        }

                        var code = GenerateMapperMethod(compilation, info);
                        context.AddSource($"{mapper.Name}_{sourceType.Name}_To_{destinationType.Name}.g.cs", SourceText.From(code, Encoding.UTF8));
                    }
                    catch (Exception ex)
                    {
                        context.ReportDiagnostic(Diagnostic.Create(AOMDiagnostics.AOM000_UnhandledExceptionId, mapAttr.ApplicationSyntaxReference?.GetSyntax().GetLocation(), mapper.ToDisplayString(), ex));
                    }
                }
            }
            catch (Exception ex)
            {
                foreach (Location location in mapper.Locations)
                {
                    context.ReportDiagnostic(Diagnostic.Create(AOMDiagnostics.AOM000_UnhandledExceptionId, location, mapper.ToDisplayString(), ex));
                }
            }
        }
    }

    private static string GeneratePopulationMethod(Compilation compilation, MethodGenerationInfo info)
    {
        IndentedStringBuilder isb = new();
        var propertyAssignments = info.GeneratePropertyAssignments(compilation).ToArray();

        isb.AppendLine("// <auto-generated />");
        isb.AppendLine("");
        isb.AppendLine("using System;");
        isb.AppendLine("using System.Collections.Generic;");
        isb.AppendLine("using System.Linq;");
        isb.AppendLine("using System.ComponentModel;");
        isb.AppendLine("using AotObjectMapper.Abstractions.Models;");
        isb.AppendLine("");
        isb.AppendLine("#nullable enable");
        isb.AppendLine("");
        if(info.Namespace != string.Empty)
        {
            isb.AppendLine($"namespace {info.Namespace}");
            isb.AppendLine("{");
        }
        foreach (var classDec in info.ClassNests)
        {
            isb.AppendLine($"    public partial class {classDec}");
            isb.AppendLine("    {");
        }
        isb.AppendLine("        [EditorBrowsable(EditorBrowsableState.Never)] // Does not work with ReSharper.");
        isb.AppendLine($"        public static partial class {info.DestinationType.Name}_Utils");
        isb.AppendLine("        {");
        isb.AppendLine("            /// Populates an existing object, Designed for internal use.");
        isb.AppendLine("            [EditorBrowsable(EditorBrowsableState.Never)] // Does not work with ReSharper.");
        isb.AppendLine($"            public static void Populate({info.DestinationType.ToDisplayString()} dest, {info.SourceType.ToDisplayString()} src, MapperContextBase ctx)");
        isb.AppendLine("            {");
        isb.AppendLine("                 // Pre Map Actions");
        isb.AppendLine("                 ctx.IncrementDepth();");
        foreach (var premapMethod in info.PreMapMethods.OrderBy(x => x.Attribute.ConstructorArguments[0].Value))
        {
            isb.AppendLine();
            isb.AppendLine($"                 {premapMethod.Method.Name}(src, dest{(premapMethod.Method.Parameters.Length is 3 ? ", ctx" : "")});");
        }

        var propertiesToAsssign = propertyAssignments.Where(x => x.assignemnt is not ("null!" or "null" or "default!" or "default")).ToArray();

        if (propertiesToAsssign.Length > 0)
        {
            isb.AppendLine();
            isb.AppendLine("                 // Property Assignment");

            foreach (var prop in propertiesToAsssign)
            {
                isb.AppendLine($"                dest.{prop.propertySymbol.Name} = {prop.assignemnt};");
            }
        }

        isb.AppendLine();
        isb.AppendLine("                 // Post Map Actions");

        if (info.PostMapMethods.Length > 0)
        {
            foreach (var postMapMethod in info.PostMapMethods.OrderBy(x => x.Attribute.ConstructorArguments[0].Value))
            {
                isb.AppendLine($"                {postMapMethod.Method.Name}(dest{(postMapMethod.Method.Parameters.Length is 2 ? ", ctx" : "")});");
            }
        }

        isb.AppendLine("                ctx.DecrementDepth();");
        isb.AppendLine("            }");
        isb.AppendLine("        }");
        foreach (var _ in info.ClassNests)
        {
            isb.AppendLine("    }");
        }
        if (info.Namespace != string.Empty)
        {
            isb.AppendLine("}");
        }
        return isb.ToString();
    }

    private static string GenerateMapperMethod(Compilation compilation, MethodGenerationInfo info)
    {
        var propertyAssignments = info.GeneratePropertyAssignments(compilation).ToArray();

        IndentedStringBuilder isb = new("    ");

         isb.AppendLine("// <auto-generated />");
         foreach (var @using in info.Usings.Distinct())
         {
             isb.AppendLine($"using {@using};");
         }
         isb.AppendLine();
         isb.AppendLine("#nullable enable");
         isb.AppendLine();

         using (isb.IndentBlock($"namespace {info.Namespace}"))
         {
             foreach (var classDec in info.ClassNests.Take(info.ClassNests.Length - 1))
             {
                 isb.AppendLine($"public partial class {classDec}");
                 isb.AppendLine("{");
                 isb.IndentLevel++;
             }

             using (isb.IndentBlock($"public partial class {info.MapperType.Name} : global::AotObjectMapper.Abstractions.Models.IMapper<global::{info.SourceType.ToDisplayString()}, global::{info.DestinationType.ToDisplayString()}>"))
             {
                 GenerateMethodDocs(info, isb);

                 using (isb.IndentBlock($"public static global::{info.DestinationType.ToDisplayString()} Map(global::{info.SourceType.ToDisplayString()} src, global::AotObjectMapper.Abstractions.Models.MapperContextBase? ctx = null)"))
                 {
                     if (info.DestinationType.TypeKind is TypeKind.Interface || info.DestinationType.IsAbstract)
                     {
                         isb.AppendLine($"return {GeneratorUtils.NoInstanceTypeMapSwitchStatement("src", info)};");
                     }
                     else if (info.PreserveReferences)
                     {
                         if (GeneratorUtils.InstanceTypeMapSwitchStatement("src", info, out var statement))
                             isb.AppendLine($"{statement}");

                         isb.AppendLine("ctx ??= new global::AotObjectMapper.Abstractions.Models.MapperContext();");

                         var ctor = info.DestinationType.BlankTypeConstructor(info, out var ctorArgs);

                         isb.AppendLine($"return ctx.GetOrMapObject<global::{info.SourceType.ToDisplayString()}, global::{info.DestinationType.ToDisplayString()}>(src, ctx, static ({(ctorArgs.Any() ? string.Join(", ", ctorArgs.Select(x => $"{x.type} {x.argName}")) : "")}) => {ctor}, {info.DestinationType.Name}_Utils.Populate);");
                     }
                     else
                     {
                         if (GeneratorUtils.InstanceTypeMapSwitchStatement("src", info, out var statement))
                             isb.AppendLine($"{statement}");
                         isb.AppendLine("ctx ??= new global::AotObjectMapper.Abstractions.Models.MapperContext();");
                         isb.AppendLine();
                         isb.AppendLine("// Pre-Map Actions");
                         isb.AppendLine("ctx.IncrementDepth();");
                         isb.AppendLine($"var dest = {info.DestinationType.BlankTypeConstructor(info, out _)};");

                         foreach (var mapMethodInfo in info.PreMapMethods.OrderBy(x => x.Attribute.ConstructorArguments[0].Value))
                         {
                             isb.AppendLine();
                             isb.AppendLine($"{mapMethodInfo.Method.Name}(src, dest{(mapMethodInfo.Method.Parameters.Length is 3 ? ", ctx" : "")});");
                         }

                         if (propertyAssignments.Any())
                         {
                             isb.AppendLine();
                             isb.AppendLine("// Property Assignment");

                             foreach (var propertyAssignment in propertyAssignments)
                             {
                                 isb.AppendLine($"dest.{propertyAssignment.propertySymbol.Name} = {propertyAssignment.assignemnt};");
                             }
                         }

                         isb.AppendLine();
                         isb.AppendLine("// Post-Map Actions");

                         if (info.PostMapMethods.Any())
                         {
                             foreach (var mapMethodInfo in info.PostMapMethods.OrderBy(x => x.Attribute.ConstructorArguments[0].Value))
                             {
                                 isb.AppendLine($"{mapMethodInfo.Method.Name}(dest{(mapMethodInfo.Method.Parameters.Length is 2 ? ", ctx" : "")});");
                             }
                         }

                         isb.AppendLine("ctx.DecrementDepth();");
                         isb.AppendLine("return dest;");
                     }
                 }
             }

             for (;isb.IndentLevel > 1;)
             {
                 isb.IndentLevel--;
                 isb.AppendLine("}");
             }
         }

         return isb.ToString();
    }

    private static void GenerateMethodDocs(MethodGenerationInfo info, IndentedStringBuilder isb)
    {
        isb.AppendLine("/// <param name=\"ctx\">Context used to manage state wile mapping</param>");
        isb.AppendLine("/// <param name=\"src\">The source object to map</param>");
        isb.AppendLine("/// <returns>");
        isb.AppendLine($"/// <see cref=\"global::{info.DestinationType.ToDisplayString()}\">{info.DestinationType.Name}</see> mapped from an instance of <see cref=\"global::{info.SourceType.ToDisplayString()}\">{info.SourceType.Name}</see>.");
        isb.AppendLine("/// </returns>");

        if (info.PreserveReferences)
        {
            isb.AppendLine("/// <remarks>");
            isb.AppendLine("/// References are preserved<br/>");
            isb.AppendLine("/// </remarks>");
        }

        if (info.SuppressNullWarnings)
        {
            isb.AppendLine("/// <remarks>");
            isb.AppendLine("// Null Warnings Are Suppressed.<br/>");
            isb.AppendLine("/// </remarks>");
        }

        if (info.IgnoredMembers.Length is not 0)
        {
            isb.AppendLine("// <remarks>");
            isb.AppendLine($"/// Ignores: {string.Join(", ", info.IgnoredMembers.Select(x => $"<see cref=\"{info.DestinationType.Name}.{x}\">{x}</see>"))}");
            isb.AppendLine("/// </remarks>");
        }
    }
}