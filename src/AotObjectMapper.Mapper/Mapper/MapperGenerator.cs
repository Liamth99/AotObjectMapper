using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace AotObjectMapper.Mapper;

#pragma warning disable RS1038
[Generator]
public class MapperGenerator : IIncrementalGenerator
{
    /// <inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var mapperClasses = context
                           .SyntaxProvider
                           .CreateSyntaxProvider(
                                predicate: (node, _) => node is ClassDeclarationSyntax cds && cds.AttributeLists.Count > 0,
                                transform: (ctx,  _) => GetMapperCandidate(ctx)
                            )
                           .Where(x => x is not null);

        var compilationAndMappers = context.CompilationProvider.Combine(mapperClasses.Collect());

        context.RegisterSourceOutput(compilationAndMappers, (spc, source) => Execute(source.Left ,source.Right, spc));
    }

    private static INamedTypeSymbol? GetMapperCandidate(GeneratorSyntaxContext context)
    {
        var classSyntax = (ClassDeclarationSyntax)context.Node;
        var symbol      = context.SemanticModel.GetDeclaredSymbol(classSyntax);

        if (symbol is null)
            return null;

        if (symbol.GetAttributes().Any(attr => attr.AttributeClass?.Name == nameof(GenerateMapperAttribute)))
        {
            return symbol as INamedTypeSymbol;
        }

        return null;
    }

    private static void Execute(Compilation compilation, ImmutableArray<INamedTypeSymbol?> mappers, SourceProductionContext context)
    {
        foreach (var mapper in mappers.Distinct(SymbolEqualityComparer.Default))
        {
            if (mapper is null)
                continue;

            var attributes = mapper.GetAttributes();

            var mapAttributes = attributes.Where(a => a.AttributeClass?.Name == nameof(MapAttribute<,>));

            foreach (var mapAttr in mapAttributes)
            {
                var sourceType      = mapAttr.AttributeClass!.TypeArguments[0];
                var destinationType = mapAttr.AttributeClass!.TypeArguments[1];

                var info = new MethodGenerationInfo((INamedTypeSymbol)mapper, sourceType, destinationType);

                if (info.DestinationType.TypeKind is not TypeKind.Interface || !info.DestinationType.IsAbstract)
                {
                    var populateCode = GeneratePopulationMethod(compilation, info);
                    context.AddSource($"Populate_{mapper.Name}_{sourceType.Name}_To_{destinationType.Name}.g.cs", SourceText.From(populateCode, Encoding.UTF8));
                }

                var code = GenerateMapperMethod(compilation, info);
                context.AddSource($"{mapper.Name}_{sourceType.Name}_To_{destinationType.Name}.g.cs", SourceText.From(code, Encoding.UTF8));
            }
        }
    }

    private static string GeneratePopulationMethod(Compilation compilation, MethodGenerationInfo info)
    {
        StringBuilder sb                  = new();
        var           propertyAssignments = info.GeneratePropertyAssignments(compilation).ToArray();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.ComponentModel;");
        sb.AppendLine("using AotObjectMapper.Abstractions.Models;");
        sb.AppendLine("");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("");
        sb.AppendLine($"namespace {info.Namespace}");
        sb.AppendLine($"{{");
        sb.AppendLine($"    public partial class {info.MapperType.Name}");
        sb.AppendLine($"    {{");
        sb.AppendLine($"        [EditorBrowsable(EditorBrowsableState.Never)] // Does not work with ReSharper.");
        sb.AppendLine($"        public static partial class {info.DestinationType.Name}_Utils");
        sb.AppendLine($"        {{");
        sb.AppendLine($"            /// Populates an existing object, Designed for internal use.");
        sb.AppendLine($"            [EditorBrowsable(EditorBrowsableState.Never)] // Does not work with ReSharper.");
        sb.AppendLine($"            public static void Populate({info.DestinationType.ToDisplayString()} dest, {info.SourceType.ToDisplayString()} src, MapperContext ctx)");
        sb.AppendLine($"            {{");
        sb.AppendLine($"                 // Pre Map Actions");
        sb.AppendLine($"                 ctx.IncrementDepth();");
        sb.AppendLine($"{string.Join("\n", info.PreMapMethods.OrderBy(x => x.Attribute.ConstructorArguments[0].Value).Select(x => $"                 {x.Method.Name}(src, dest{(x.Method.Parameters.Length is 3 ? ", ctx" : "")});"))}");
        sb.AppendLine($"                 // Property Assignment");
        sb.AppendLine($"{string.Join("\n", propertyAssignments.Where(x => x.assignemnt is not ("null!" or "null" or "default!" or "default")).Select(x => $"                dest.{x.propertySymbol.Name} = {x.assignemnt};"))}");
        sb.AppendLine($"                 // Post Map Actions");
        sb.AppendLine($"{string.Join("\n", info.PostMapMethods.OrderBy(x => x.Attribute.ConstructorArguments[0].Value).Select(x => $"                {x.Method.Name}(dest{(x.Method.Parameters.Length is 2 ? ", ctx" : "")});"))}");
        sb.AppendLine($"                 ctx.DecrementDepth();");
        sb.AppendLine($"             }}");
        sb.AppendLine($"        }}");
        sb.AppendLine($"    }}");
        sb.AppendLine($"}}");

        return sb.ToString();
    }

    private static string GenerateMapperMethod(Compilation compilation, MethodGenerationInfo info)
    {
        var propertyAssignments = info.GeneratePropertyAssignments(compilation).ToArray();

        StringBuilder mapMethodSb = new();

        if (info.DestinationType.TypeKind is TypeKind.Interface || info.DestinationType.IsAbstract)
        {
            mapMethodSb.AppendLine($"            return {GeneratorUtils.NoInstanceTypeMapSwitchStatement("src", info)};");
        }
        else if (info.PreserveReferences)
        {
            if(GeneratorUtils.InstanceTypeMapSwitchStatement("src", info, out var statement))
                mapMethodSb.AppendLine($"            {statement}");
            mapMethodSb.AppendLine($"            ctx ??= new MapperContext();");
            mapMethodSb.AppendLine($"            return ctx.GetOrMapObject<{info.SourceType.Name}, {info.DestinationType.Name}>(src, ctx, static () => {info.DestinationType.BlankTypeConstructor()}, {info.DestinationType.Name}_Utils.Populate);");
        }
        else
        {
            if(GeneratorUtils.InstanceTypeMapSwitchStatement("src", info, out var statement))
                mapMethodSb.AppendLine($"            {statement}");
            mapMethodSb.AppendLine($"            ctx ??= new MapperContext();");
            mapMethodSb.AppendLine($"");
            mapMethodSb.AppendLine($"            // Pre Map Actions");
            mapMethodSb.AppendLine($"            ctx.IncrementDepth();");
            mapMethodSb.AppendLine($"            var dest = {info.DestinationType.BlankTypeConstructor()};");

            foreach (var mapMethodInfo in info.PreMapMethods.OrderBy(x => x.Attribute.ConstructorArguments[0].Value))
            {
                mapMethodSb.AppendLine();
                mapMethodSb.AppendLine($"            {mapMethodInfo.Method.Name}(src, dest{(mapMethodInfo.Method.Parameters.Length is 3 ? ", ctx" : "")});");
            }

            if (propertyAssignments.Any())
            {
                mapMethodSb.AppendLine();
                mapMethodSb.AppendLine("            // Property Assignment");

                foreach (var propertyAssignment in propertyAssignments)
                {
                    mapMethodSb.AppendLine($"            dest.{propertyAssignment.propertySymbol.Name} = {propertyAssignment.assignemnt};");
                }
            }

            if (info.PostMapMethods.Any())
            {
                mapMethodSb.AppendLine();
                mapMethodSb.AppendLine("            // Post Map Actions");
                foreach (var mapMethodInfo in info.PostMapMethods.OrderBy(x => x.Attribute.ConstructorArguments[0].Value))
                {
                    mapMethodSb.AppendLine($"            {mapMethodInfo.Method.Name}(dest{(mapMethodInfo.Method.Parameters.Length is 2 ? ", ctx" : "")});");
                }
            }

            mapMethodSb.AppendLine("            ctx.DecrementDepth();");
            mapMethodSb.AppendLine("            return dest;");
        }

        return $$"""
                 // <auto-generated />

                 {{string.Join("\n", info.Usings.Distinct().Select(x => $"using {x};"))}}

                 #nullable enable

                 namespace {{info.Namespace}}
                 {
                     public partial class {{info.MapperType.Name}} : IMapper<{{info.SourceType.Name}}, {{info.DestinationType.Name}}>
                     {
                 {{GenerateMethodDocs(info)}}        [Pure]
                         public static {{info.DestinationType.Name}} Map({{info.SourceType.Name}} src, MapperContext? ctx = null)
                         {
                 {{mapMethodSb}}
                         }
                     }
                 }
                 """;
    }

    private static string GenerateMethodDocs(MethodGenerationInfo info)
    {
        StringBuilder sb = new();

        sb.AppendLine("        /// <param name=\"ctx\">Context used to manage state wile mapping</param>");
        sb.AppendLine("        /// <param name=\"src\">The source object to map</param>");
        sb.AppendLine("        /// <returns>");
        sb.AppendLine($"        /// <see cref=\"{info.DestinationType.Name}\"/> mapped from an instance of <see cref=\"{info.SourceType.Name}\"/>.");
        sb.AppendLine("        /// </returns>");

        if (info.PreserveReferences)
        {
            sb.AppendLine("        /// <remarks>");
            sb.AppendLine("        /// References are preserved<br/>");
            sb.AppendLine("        /// </remarks>");
        }

        if (info.SuppressNullWarnings)
        {
            sb.AppendLine("        /// <remarks>");
            sb.AppendLine("        /// Null Warnings Are Suppressed.<br/>");
            sb.AppendLine("        /// </remarks>");
        }

        if (info.IgnoredMembers.Length is not 0)
        {
            sb.AppendLine("        /// <remarks>");
            sb.AppendLine($"        /// Ignores: {string.Join(", ", info.IgnoredMembers.Select(x => $"<see cref=\"{info.DestinationType.Name}.{x}\">{x}</see>"))}");
            sb.AppendLine("        /// </remarks>");
        }

        return sb.ToString();
    }
}