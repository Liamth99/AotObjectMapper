using System;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace AotObjectMapper.Mapper;

#pragma warning disable RS1038
[Generator]
public class MapperGenerator : IIncrementalGenerator
{
    /// <inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var mapperClasses = context
                           .SyntaxProvider
                           .CreateSyntaxProvider(
                                predicate: (node, _) => node is ClassDeclarationSyntax cds && cds.AttributeLists.Count > 0,
                                transform: (ctx,  _) => GetMapperCandidate(ctx)
                            )
                           .Where(x => x is not null);

        var compilationAndMappers = context.CompilationProvider.Combine(mapperClasses.Collect());

        context.RegisterSourceOutput(compilationAndMappers, (spc, source) => Execute(source.Left ,source.Right, spc));
    }

    private static INamedTypeSymbol? GetMapperCandidate(GeneratorSyntaxContext context)
    {
        var classSyntax = (ClassDeclarationSyntax)context.Node;
        var symbol      = context.SemanticModel.GetDeclaredSymbol(classSyntax);

        if (symbol is null)
            return null;

        if (symbol.GetAttributes().Any(attr => attr.AttributeClass?.Name == nameof(GenerateMapperAttribute)))
        {
            return symbol as INamedTypeSymbol;
        }

        return null;
    }

    private static void Execute(Compilation compilation, ImmutableArray<INamedTypeSymbol?> mappers, SourceProductionContext context)
    {
        foreach (var mapper in mappers.Distinct(SymbolEqualityComparer.Default))
        {
            if (mapper is null)
                continue;

            var attributes = mapper.GetAttributes();

            var mapAttributes = attributes.Where(a => a.AttributeClass?.Name == nameof(MapAttribute<,>));

            foreach (var mapAttr in mapAttributes)
            {
                try
                {
                    var sourceType      = mapAttr.AttributeClass!.TypeArguments[0];
                    var destinationType = mapAttr.AttributeClass!.TypeArguments[1];

                    var info = new MethodGenerationInfo((INamedTypeSymbol)mapper, sourceType, destinationType);

                    if (info.DestinationType.TypeKind is not TypeKind.Interface || !info.DestinationType.IsAbstract)
                    {
                        var populateCode = GeneratePopulationMethod(compilation, info);
                        context.AddSource($"Populate_{mapper.Name}_{sourceType.Name}_To_{destinationType.Name}.g.cs", SourceText.From(populateCode, Encoding.UTF8));
                    }

                    var code = GenerateMapperMethod(compilation, info);
                    context.AddSource($"{mapper.Name}_{sourceType.Name}_To_{destinationType.Name}.g.cs", SourceText.From(code, Encoding.UTF8));
                }
                catch (Exception ex)
                {
                    foreach (Location location in mapper.Locations)
                    {
                        context.ReportDiagnostic(Diagnostic.Create(AOMDiagnostics.AOM000_UnhandledExceptionId, location, mapper.ToDisplayString(), ex));
                    }
                }
            }
        }
    }

    private static string GeneratePopulationMethod(Compilation compilation, MethodGenerationInfo info)
    {
        StringBuilder sb                  = new();
        var           propertyAssignments = info.GeneratePropertyAssignments(compilation).ToArray();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using System.ComponentModel;");
        sb.AppendLine("using AotObjectMapper.Abstractions.Models;");
        sb.AppendLine("");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("");
        if(info.Namespace != string.Empty)
        {
            sb.AppendLine($"namespace {info.Namespace}");
            sb.AppendLine($"{{");
        }
        foreach (var classDec in info.ClassNests)
        {
            sb.AppendLine($"    public partial class {classDec}");
            sb.AppendLine($"    {{");
        }
        sb.AppendLine($"        [EditorBrowsable(EditorBrowsableState.Never)] // Does not work with ReSharper.");
        sb.AppendLine($"        public static partial class {info.DestinationType.Name}_Utils");
        sb.AppendLine($"        {{");
        sb.AppendLine($"            /// Populates an existing object, Designed for internal use.");
        sb.AppendLine($"            [EditorBrowsable(EditorBrowsableState.Never)] // Does not work with ReSharper.");
        sb.AppendLine($"            public static void Populate({info.DestinationType.ToDisplayString()} dest, {info.SourceType.ToDisplayString()} src, MapperContext ctx)");
        sb.AppendLine($"            {{");
        sb.AppendLine($"                 // Pre Map Actions");
        sb.AppendLine($"                 ctx.IncrementDepth();");
        foreach (var premapMethod in info.PreMapMethods.OrderBy(x => x.Attribute.ConstructorArguments[0].Value))
        {
            sb.AppendLine();
            sb.AppendLine($"                 {premapMethod.Method.Name}(src{(premapMethod.Method.Parameters.Length is 3 ? ", ctx" : "")});");
        }

        var propertiesToAsssign = propertyAssignments.Where(x => x.assignemnt is not ("null!" or "null" or "default!" or "default")).ToArray();

        if (propertiesToAsssign.Length > 0)
        {
            sb.AppendLine();
            sb.AppendLine($"                 // Property Assignment");

            foreach (var prop in propertiesToAsssign)
            {
                sb.AppendLine($"                dest.{prop.propertySymbol.Name} = {prop.assignemnt};");
            }
        }

        sb.AppendLine();
        sb.AppendLine($"                 // Post Map Actions");

        if (info.PostMapMethods.Length > 0)
        {
            foreach (var postMapMethod in info.PostMapMethods.OrderBy(x => x.Attribute.ConstructorArguments[0].Value))
            {
                sb.AppendLine($"                {postMapMethod.Method.Name}(dest{(postMapMethod.Method.Parameters.Length is 2 ? ", ctx" : "")});");
            }
        }

        sb.AppendLine("                ctx.DecrementDepth();");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        foreach (var _ in info.ClassNests)
        {
            sb.AppendLine("    }");
        }
        if (info.Namespace != string.Empty)
        {
            sb.AppendLine("}");
        }
        return sb.ToString();
    }

    private static string GenerateMapperMethod(Compilation compilation, MethodGenerationInfo info)
    {
        var propertyAssignments = info.GeneratePropertyAssignments(compilation).ToArray();

        StringBuilder mapMethodSb = new();

         mapMethodSb.AppendLine("// <auto-generated />");
         foreach (var @using in info.Usings.Distinct())
         {
             mapMethodSb.AppendLine($"using {@using};");
         }
         mapMethodSb.AppendLine();
         mapMethodSb.AppendLine("#nullable enable");
         mapMethodSb.AppendLine();
         if(info.Namespace != string.Empty)
         {
             mapMethodSb.AppendLine($"namespace {info.Namespace}");
             mapMethodSb.AppendLine($"{{");
         }
         foreach (var classDec in info.ClassNests.Take(info.ClassNests.Length - 1))
         {
             mapMethodSb.AppendLine($"    public partial class {classDec}");
             mapMethodSb.AppendLine($"    {{");
         }
         mapMethodSb.AppendLine($"    public partial class {info.MapperType.Name} : IMapper<{info.SourceType.Name}, {info.DestinationType.Name}>");
         mapMethodSb.AppendLine("    {");
         mapMethodSb.AppendLine("        [Pure]");
         GenerateMethodDocs(info, mapMethodSb);
         mapMethodSb.AppendLine($"        public static {info.DestinationType.Name} Map({info.SourceType.Name} src, MapperContext? ctx = null)");
         mapMethodSb.AppendLine("        {");

        if (info.DestinationType.TypeKind is TypeKind.Interface || info.DestinationType.IsAbstract)
        {
            mapMethodSb.AppendLine($"            return {GeneratorUtils.NoInstanceTypeMapSwitchStatement("src", info)};");
        }
        else if (info.PreserveReferences)
        {
            if(GeneratorUtils.InstanceTypeMapSwitchStatement("src", info, out var statement))
                mapMethodSb.AppendLine($"            {statement}");
            mapMethodSb.AppendLine($"            ctx ??= new MapperContext();");
            mapMethodSb.AppendLine($"            return ctx.GetOrMapObject<{info.SourceType.Name}, {info.DestinationType.Name}>(src, ctx, static () => {info.DestinationType.BlankTypeConstructor()}, {info.DestinationType.Name}_Utils.Populate);");
        }
        else
        {
            if(GeneratorUtils.InstanceTypeMapSwitchStatement("src", info, out var statement))
                mapMethodSb.AppendLine($"            {statement}");
            mapMethodSb.AppendLine($"            ctx ??= new MapperContext();");
            mapMethodSb.AppendLine($"");
            mapMethodSb.AppendLine($"            // Pre Map Actions");
            mapMethodSb.AppendLine($"            ctx.IncrementDepth();");
            mapMethodSb.AppendLine($"            var dest = {info.DestinationType.BlankTypeConstructor()};");

            foreach (var mapMethodInfo in info.PreMapMethods.OrderBy(x => x.Attribute.ConstructorArguments[0].Value))
            {
                mapMethodSb.AppendLine();
                mapMethodSb.AppendLine($"            {mapMethodInfo.Method.Name}(src, dest{(mapMethodInfo.Method.Parameters.Length is 3 ? ", ctx" : "")});");
            }

            if (propertyAssignments.Any())
            {
                mapMethodSb.AppendLine();
                mapMethodSb.AppendLine("            // Property Assignment");

                foreach (var propertyAssignment in propertyAssignments)
                {
                    mapMethodSb.AppendLine($"            dest.{propertyAssignment.propertySymbol.Name} = {propertyAssignment.assignemnt};");
                }
            }

            mapMethodSb.AppendLine();
            mapMethodSb.AppendLine("            // Post Map Actions");

            if (info.PostMapMethods.Any())
            {
                foreach (var mapMethodInfo in info.PostMapMethods.OrderBy(x => x.Attribute.ConstructorArguments[0].Value))
                {
                    mapMethodSb.AppendLine($"            {mapMethodInfo.Method.Name}(dest{(mapMethodInfo.Method.Parameters.Length is 2 ? ", ctx" : "")});");
                }
            }

            mapMethodSb.AppendLine("            ctx.DecrementDepth();");
            mapMethodSb.AppendLine("            return dest;");
        }

        mapMethodSb.AppendLine("        }");
        foreach (var _ in info.ClassNests)
        {
            mapMethodSb.AppendLine("    }");
        }
        if(info.Namespace != string.Empty)
            mapMethodSb.AppendLine("}");

        return mapMethodSb.ToString();
    }

    private static void GenerateMethodDocs(MethodGenerationInfo info, StringBuilder sb)
    {
        sb.AppendLine("        /// <param name=\"ctx\">Context used to manage state wile mapping</param>");
        sb.AppendLine("        /// <param name=\"src\">The source object to map</param>");
        sb.AppendLine("        /// <returns>");
        sb.AppendLine($"        /// <see cref=\"{info.DestinationType.Name}\"/> mapped from an instance of <see cref=\"{info.SourceType.Name}\"/>.");
        sb.AppendLine("        /// </returns>");

        if (info.PreserveReferences)
        {
            sb.AppendLine("        /// <remarks>");
            sb.AppendLine("        /// References are preserved<br/>");
            sb.AppendLine("        /// </remarks>");
        }

        if (info.SuppressNullWarnings)
        {
            sb.AppendLine("        /// <remarks>");
            sb.AppendLine("        /// Null Warnings Are Suppressed.<br/>");
            sb.AppendLine("        /// </remarks>");
        }

        if (info.IgnoredMembers.Length is not 0)
        {
            sb.AppendLine("        /// <remarks>");
            sb.AppendLine($"        /// Ignores: {string.Join(", ", info.IgnoredMembers.Select(x => $"<see cref=\"{info.DestinationType.Name}.{x}\">{x}</see>"))}");
            sb.AppendLine("        /// </remarks>");
        }
    }
}