using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using AotObjectMapper.Mapper.Info;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace AotObjectMapper.Mapper;

#pragma warning disable RS1038
[Generator]
public class MapperGenerator : IIncrementalGenerator
{
    /// <inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var mapperClasses = context
                           .SyntaxProvider
                           .CreateSyntaxProvider(
                                predicate: (node, _) => node is ClassDeclarationSyntax cds && cds.AttributeLists.Count > 0,
                                transform: (ctx,  _) => GetMapperCandidate(ctx)
                            )
                           .Where(x => x is not null);

        var compilationAndMappers = context.CompilationProvider.Combine(mapperClasses.Collect());

        context.RegisterSourceOutput(compilationAndMappers, (spc, source) => Execute(source.Left ,source.Right, spc));
    }

    private static INamedTypeSymbol? GetMapperCandidate(GeneratorSyntaxContext context)
    {
        var classSyntax = (ClassDeclarationSyntax)context.Node;
        var symbol      = context.SemanticModel.GetDeclaredSymbol(classSyntax);

        if (symbol is null)
            return null;

        if (symbol.GetAttributes().Any(attr => attr.AttributeClass?.Name == nameof(GenerateMapperAttribute)))
        {
            return symbol as INamedTypeSymbol;
        }

        return null;
    }

    private static void Execute(Compilation compilation, ImmutableArray<INamedTypeSymbol?> mappers, SourceProductionContext context)
    {
        foreach (var mapper in mappers.Distinct(SymbolEqualityComparer.Default))
        {
            if (mapper is null)
                continue;

            try
            {
                var code = GenerateMapperClass(compilation, mapper, context);
                context.AddSource($"{mapper.OriginalDefinition}.g.cs", SourceText.From(code, Encoding.UTF8));
            }
            catch (Exception ex)
            {
                foreach (Location location in mapper.Locations)
                {
                    context.ReportDiagnostic(Diagnostic.Create(AOMDiagnostics.AOM000_UnhandledExceptionId, location, mapper.ToDisplayString(), ex));
                }
            }
        }
    }

    private static string GenerateMapperClass(Compilation compilation, ISymbol mapper, SourceProductionContext context)
    {
        var attributes = mapper.GetAttributes();

        var mapAttributes = attributes.Where(a => a.AttributeClass?.Name == nameof(MapAttribute<,>));

        IndentedStringBuilder isb = new ();

        isb.AppendLine("// <auto-generated />");
        isb.AppendLine();
        isb.AppendLine("using System;");
        isb.AppendLine("using System.Collections.Generic;");
        isb.AppendLine("using System.Linq;");
        isb.AppendLine();
        isb.AppendLine("#nullable enable");
        isb.AppendLine();

        string @namespace = mapper.ContainingNamespace.ToDisplayString() == "<global namespace>" ? string.Empty : mapper.ContainingNamespace.ToDisplayString();
        var    classNests = new string(mapper.OriginalDefinition.ToString().Skip(@namespace.Length).ToArray()).Split(['.'], StringSplitOptions.RemoveEmptyEntries).ToArray();

        List<MethodGenerationInfo> methodGenInfos = [];

        foreach (var mapAttr in mapAttributes)
        {
            var info = new MethodGenerationInfo((INamedTypeSymbol)mapper, mapAttr);

            methodGenInfos.Add(info);
        }

        using (isb.IndentBlock($"namespace {@namespace}"))
        {
            foreach (var classDec in classNests.Take(classNests.Length - 1))
            {
                isb.AppendLine($"public partial class {classDec}");
                isb.AppendLine("{");
                isb.IndentLevel++;
            }

            List<string> interfaces = [];

            foreach (var methodGenInfo in methodGenInfos)
            {
                interfaces.Add($"global::AotObjectMapper.Abstractions.Models.IMapper<global::{methodGenInfo.SourceType.ToDisplayString()}, global::{methodGenInfo.DestinationType.ToDisplayString()}>");
            }

            using (isb.IndentBlock($"public partial class {mapper.Name} : {string.Join(", ", interfaces)}"))
            {
                foreach (var methodGenInfo in methodGenInfos)
                {
                    try
                    {
                        GenerateMapperMethod(compilation, isb, methodGenInfo);
                        isb.AppendLine();
                    }
                    catch (Exception ex)
                    {
                        context.ReportDiagnostic(Diagnostic.Create(AOMDiagnostics.AOM000_UnhandledExceptionId, methodGenInfo.MapAttribute.ApplicationSyntaxReference?.GetSyntax().GetLocation(), mapper.ToDisplayString(), ex));
                    }
                }

                isb.AppendLine("[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]");
                using (isb.IndentBlock("public static partial class Utils"))
                {
                    foreach (var methodGenInfo in methodGenInfos)
                    {
                        try
                        {
                            GeneratePopulationMethod(compilation, isb, methodGenInfo);
                            isb.AppendLine();
                        }
                        catch (Exception ex)
                        {
                            context.ReportDiagnostic(Diagnostic.Create(AOMDiagnostics.AOM000_UnhandledExceptionId, methodGenInfo.MapAttribute.ApplicationSyntaxReference?.GetSyntax().GetLocation(), mapper.ToDisplayString(), ex));
                        }
                    }
                }
            }

            for (; isb.IndentLevel > 1;)
            {
                isb.IndentLevel--;
                isb.AppendLine("}");
            }
        }

        return isb.ToString();
    }

    private static void GenerateMapperMethod(Compilation compilation, IndentedStringBuilder isb, MethodGenerationInfo info)
    {
        var propertyAssignments = info.GeneratePropertyAssignments(compilation).ToArray();

        GenerateMethodDocs(info, isb);

        using (isb.IndentBlock($"public static global::{info.DestinationType.ToDisplayString()} Map(global::{info.SourceType.ToDisplayString()} src, global::AotObjectMapper.Abstractions.Models.MapperContextBase? ctx = null)"))
        {
            if (info.DestinationType.TypeKind is TypeKind.Interface || info.DestinationType.IsAbstract)
            {
                isb.AppendLine($"return {GeneratorUtils.NoInstanceTypeMapSwitchStatement("src", info)};");
            }
            else if (info.PreserveReferences)
            {
                if (GeneratorUtils.InstanceTypeMapSwitchStatement("src", info, out var statement))
                    isb.AppendLine($"{statement}");

                isb.AppendLine("ctx ??= new global::AotObjectMapper.Abstractions.Models.MapperContext();");

                var ctor = info.DestinationType.BlankTypeConstructor(info, out var ctorArgs);

                isb.AppendLine($"return ctx.GetOrMapObject<global::{info.SourceType.ToDisplayString()}, global::{info.DestinationType.ToDisplayString()}>(src, ctx, static ({(ctorArgs.Any() ? string.Join(", ", ctorArgs.Select(x => $"{x.type} {x.argName}")) : "")}) => {ctor}, Utils.Populate);");
            }
            else
            {
                if (GeneratorUtils.InstanceTypeMapSwitchStatement("src", info, out var statement))
                    isb.AppendLine($"{statement}");
                isb.AppendLine("ctx ??= new global::AotObjectMapper.Abstractions.Models.MapperContext();");
                isb.AppendLine();
                isb.AppendLine("// Pre-Map Actions");
                isb.AppendLine("ctx.IncrementDepth();");
                isb.AppendLine($"var dest = {info.DestinationType.BlankTypeConstructor(info, out _)};");

                foreach (var mapMethodInfo in info.PreMapMethods.OrderBy(x => x.Attribute.ConstructorArguments[0].Value))
                {
                    isb.AppendLine();
                    isb.AppendLine($"{mapMethodInfo.Symbol.Name}(src, dest{(mapMethodInfo.Symbol.Parameters.Length is 3 ? ", ctx" : "")});");
                }

                if (propertyAssignments.Any())
                {
                    isb.AppendLine();
                    isb.AppendLine("// Property Assignment");

                    foreach (var propertyAssignment in propertyAssignments)
                    {
                        isb.AppendLine($"dest.{propertyAssignment.propertySymbol.Name} = {propertyAssignment.assignemnt};");
                    }
                }

                isb.AppendLine();
                isb.AppendLine("// Post-Map Actions");

                if (info.PostMapMethods.Any())
                {
                    foreach (var mapMethodInfo in info.PostMapMethods.OrderBy(x => x.Attribute.ConstructorArguments[0].Value))
                    {
                        isb.AppendLine($"{mapMethodInfo.Symbol.Name}(dest{(mapMethodInfo.Symbol.Parameters.Length is 2 ? ", ctx" : "")});");
                    }
                }

                isb.AppendLine("ctx.DecrementDepth();");
                isb.AppendLine("return dest;");
            }
        }
    }

    private static void GenerateMethodDocs(MethodGenerationInfo info, IndentedStringBuilder isb)
    {
        isb.AppendLine("/// <param name=\"ctx\">Context used to manage state wile mapping</param>");
        isb.AppendLine("/// <param name=\"src\">The source object to map</param>");
        isb.AppendLine("/// <returns>");
        isb.AppendLine($"/// <see cref=\"global::{info.DestinationType.ToDisplayString()}\">{info.DestinationType.Name}</see> mapped from an instance of <see cref=\"global::{info.SourceType.ToDisplayString()}\">{info.SourceType.Name}</see>.");
        isb.AppendLine("/// </returns>");

        if (info.PreserveReferences)
        {
            isb.AppendLine("/// <remarks>");
            isb.AppendLine("/// References are preserved<br/>");
            isb.AppendLine("/// </remarks>");
        }

        if (info.SuppressNullWarnings)
        {
            isb.AppendLine("/// <remarks>");
            isb.AppendLine("// Null Warnings Are Suppressed.<br/>");
            isb.AppendLine("/// </remarks>");
        }

        if (info.IgnoredMembers.Length is not 0)
        {
            isb.AppendLine("// <remarks>");
            isb.AppendLine($"/// Ignores: {string.Join(", ", info.IgnoredMembers.Select(x => $"<see cref=\"{info.DestinationType.Name}.{x}\">{x}</see>"))}");
            isb.AppendLine("/// </remarks>");
        }
    }

    private static void GeneratePopulationMethod(Compilation compilation, IndentedStringBuilder isb , MethodGenerationInfo info)
    {
        var propertyAssignments = info.GeneratePropertyAssignments(compilation).ToArray();

        isb.AppendLine("/// Populates an existing object, Designed for internal use.");
        isb.AppendLine("[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]");

        using (isb.IndentBlock($"public static void Populate(global::{info.DestinationType.ToDisplayString()} dest, global::{info.SourceType.ToDisplayString()} src, global::AotObjectMapper.Abstractions.Models.MapperContextBase ctx)"))
        {

            isb.AppendLine("// Pre-Map Actions");
            isb.AppendLine("ctx.IncrementDepth();");
            foreach (var premapMethod in info.PreMapMethods.OrderBy(x => x.Attribute.ConstructorArguments[0].Value))
            {
                isb.AppendLine();
                isb.AppendLine($"{premapMethod.Symbol.Name}(src, dest{(premapMethod.Symbol.Parameters.Length is 3 ? ", ctx" : "")});");
            }

            var propertiesToAssign = propertyAssignments.Where(x => x.assignemnt is not ("null!" or "null" or "default!" or "default")).ToArray();

            if (propertiesToAssign.Length > 0)
            {
                isb.AppendLine();
                isb.AppendLine("// Property Assignment");

                foreach (var prop in propertiesToAssign)
                {
                    isb.AppendLine($"dest.{prop.propertySymbol.Name} = {prop.assignemnt};");
                }
            }

            isb.AppendLine();
            isb.AppendLine("// Post-Map Actions");

            if (info.PostMapMethods.Length > 0)
            {
                foreach (var postMapMethod in info.PostMapMethods.OrderBy(x => x.Attribute.ConstructorArguments[0].Value))
                {
                    isb.AppendLine($"{postMapMethod.Symbol.Name}(dest{(postMapMethod.Symbol.Parameters.Length is 2 ? ", ctx" : "")});");
                }
            }

            isb.AppendLine("ctx.DecrementDepth();");
        }
    }
}