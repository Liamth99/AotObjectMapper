using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace AotObjectMapper.Mapper;

#pragma warning disable RS1038
[Generator]
public class MapperGenerator : IIncrementalGenerator
{
    /// <inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var mapperClasses = context
                           .SyntaxProvider
                           .CreateSyntaxProvider(
                                predicate: (node, _) => node is ClassDeclarationSyntax cds && cds.AttributeLists.Count > 0,
                                transform: (ctx,  _) => GetMapperCandidate(ctx)
                            )
                           .Where(x => x is not null);

        var compilationAndMappers = context.CompilationProvider.Combine(mapperClasses.Collect());

        context.RegisterSourceOutput(compilationAndMappers, (spc, source) => Execute(source.Left ,source.Right, spc));
    }

    private static INamedTypeSymbol? GetMapperCandidate(GeneratorSyntaxContext context)
    {
        var classSyntax = (ClassDeclarationSyntax)context.Node;
        var symbol      = context.SemanticModel.GetDeclaredSymbol(classSyntax);

        if (symbol is null)
            return null;

        if (symbol.GetAttributes().Any(attr => attr.AttributeClass?.Name == nameof(GenerateMapperAttribute)))
        {
            return symbol as INamedTypeSymbol;
        }

        return null;
    }

    private static void Execute(Compilation compilation, ImmutableArray<INamedTypeSymbol?> mappers, SourceProductionContext context)
    {
        int i = 0;
        foreach (var mapper in mappers.Distinct(SymbolEqualityComparer.Default))
        {
            if (mapper is null)
                continue;

            var attributes = mapper.GetAttributes();

            var mapAttributes = attributes.Where(a => a.AttributeClass?.Name == nameof(MapAttribute<,>));

            foreach (var mapAttr in mapAttributes)
            {
                var sourceType      = mapAttr.AttributeClass!.TypeArguments[0];
                var destinationType = mapAttr.AttributeClass!.TypeArguments[1];

                var info = new MethodInfo((INamedTypeSymbol)mapper, sourceType, destinationType);

                var populateCode = GeneratePopulationMethod(compilation, info);
                context.AddSource($"Populate_{destinationType.Name}_{(string)mapAttr.ConstructorArguments[0].Value!}_From_{sourceType.Name}_{i++}.g.cs", SourceText.From(populateCode, Encoding.UTF8));

                var code = GenerateMapperMethod(compilation, info);
                context.AddSource($"{mapper.Name}_{(string)mapAttr.ConstructorArguments[0].Value!}_{sourceType.Name}_To_{destinationType.Name}.g.cs", SourceText.From(code, Encoding.UTF8));
            }
        }
    }

    private static string GeneratePopulationMethod(Compilation compilation, MethodInfo info)
    {
        StringBuilder sb                  = new();
        var           propertyAssignments = info.GeneratePropertyAssignments(compilation).ToArray();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.ComponentModel;");
        sb.AppendLine("using AotObjectMapper.Abstractions.Models;");
        sb.AppendLine("");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("");
        sb.AppendLine($"namespace {info.Namespace}");
        sb.AppendLine($"{{");
        sb.AppendLine($"    public partial class {info.MapperType.Name}");
        sb.AppendLine($"    {{");
        sb.AppendLine($"        public static partial class {info.DestinationType.Name}_{info.MethodName}Utils");
        sb.AppendLine($"        {{");
        sb.AppendLine($"            /// Populates an existing object, Designed for internal use.");
        sb.AppendLine($"            [EditorBrowsable(EditorBrowsableState.Never)] // Does not work with ReSharper.");
        sb.AppendLine($"            public static void Populate({info.DestinationType.ToDisplayString()} destination, {info.SourceType.ToDisplayString()} source, MapperContext context)");
        sb.AppendLine($"            {{");
        sb.AppendLine($"                 // Pre Map Actions");
        sb.AppendLine($"                 context.IncrementDepth();");
        sb.AppendLine($"{string.Join("\n", info.PreMapMethods.OrderBy(x => x.Attribute.ConstructorArguments[0].Value).Select(x => $"                 {x.Method.Name}(source, destination{(x.Method.Parameters.Length is 3 ? ", context" : "")});"))}");
        sb.AppendLine($"                 // Property Assignment");
        sb.AppendLine($"{string.Join("\n", propertyAssignments.Where(x => x.assignemnt is not ("null!" or "null" or "default!" or "default")).Select(x => $"                destination.{x.propertySymbol.Name} = {x.assignemnt};"))}");
        sb.AppendLine($"                 // Post Map Actions");
        sb.AppendLine($"{string.Join("\n", info.PostMapMethods.OrderBy(x => x.Attribute.ConstructorArguments[0].Value).Select(x => $"                {x.Method.Name}(destination{(x.Method.Parameters.Length is 2 ? ", context" : "")});"))}");
        sb.AppendLine($"                 context.DecrementDepth();");
        sb.AppendLine($"             }}");
        sb.AppendLine($"        }}");
        sb.AppendLine($"    }}");
        sb.AppendLine($"}}");

        return sb.ToString();
    }

    private static string GenerateMapperMethod(Compilation compilation, MethodInfo info)
    {
        var propertyAssignments = info.GeneratePropertyAssignments(compilation).ToArray();

        string mapMethod;

        if (info.PreserveReferences)
        {
            mapMethod =
                $$"""
                              context ??= new MapperContext();
                              
                              return context.GetOrMapObject<{{info.SourceType.Name}}, {{info.DestinationType.Name}}>(source, context, static () => {{Utils.BlankTypeConstructor(info.DestinationType)}}, {{info.DestinationType.Name}}_{{info.MethodName}}Utils.Populate);
                  """;

        }
        else
        {
            mapMethod =
                $$"""
                              context ??= new MapperContext();
                  
                              // Pre Map Actions
                              context.IncrementDepth();
                              var destination = {{Utils.BlankTypeConstructor(info.DestinationType)}};
                  {{string.Join("\n", info.PreMapMethods.OrderBy(x => x.Attribute.ConstructorArguments[0].Value).Select(x => $"            {x.Method.Name}(source, destination{(x.Method.Parameters.Length is 3 ? ", context" : "")});"))}}
                  
                              // Property Assignment
                  {{string.Join("\n", propertyAssignments.Select(x => $"            destination.{x.propertySymbol.Name} = {x.assignemnt};"))}}
                  
                              // Post Map Actions
                  {{string.Join("\n", info.PostMapMethods.OrderBy(x => x.Attribute.ConstructorArguments[0].Value).Select(x => $"            {x.Method.Name}(destination{(x.Method.Parameters.Length is 2 ? ", context" : "")});"))}}
                  
                              context.DecrementDepth();
                              return destination;
                  """;
        }

        return $$"""
                 // <auto-generated />

                 {{string.Join("\n", info.Usings.Distinct().Select(x => $"using {x};"))}}

                 #nullable enable

                 namespace {{info.Namespace}}
                 {
                     public partial class {{info.MapperType.Name}} : IMapper<{{info.SourceType.Name}}, {{info.DestinationType.Name}}>
                     {
                 {{GenerateMethodDocs(info)}}        [Pure]
                         public static {{info.DestinationType.Name}} {{info.MethodName}}({{info.SourceType.Name}} source, MapperContext? context = null)
                         {
                 {{mapMethod}}
                         }
                     }
                 }
                 """;
    }

    private static string GenerateMethodDocs(MethodInfo info)
    {
        StringBuilder sb = new();

        sb.AppendLine("        /// <param name=\"context\">Context used to manage state wile mapping</param>");
        sb.AppendLine("        /// <param name=\"source\">The source object to map</param>");
        sb.AppendLine("        /// <returns>");
        sb.AppendLine($"        /// <see cref=\"{info.DestinationType.Name}\"/> mapped from an instance of <see cref=\"{info.SourceType.Name}\"/>.");
        sb.AppendLine("        /// </returns>");

        if (info.PreserveReferences)
        {
            sb.AppendLine("        /// <remarks>");
            sb.AppendLine("        /// References are preserved<br/>");
            sb.AppendLine("        /// </remarks>");
        }

        if (info.SuppressNullWarnings)
        {
            sb.AppendLine("        /// <remarks>");
            sb.AppendLine("        /// Null Warnings Are Suppressed.<br/>");
            sb.AppendLine("        /// </remarks>");
        }

        if (info.IgnoredMembers.Length is not 0)
        {
            sb.AppendLine("        /// <remarks>");
            sb.AppendLine($"        /// Ignores: {string.Join(", ", info.IgnoredMembers.Select(x => $"<see cref=\"{info.DestinationType.Name}.{x}\">{x}</see>"))}");
            sb.AppendLine("        /// </remarks>");
        }

        return sb.ToString();
    }
}